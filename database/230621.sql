-- ---------------------------------------------------
-- 230621 day5
-- ---------------------------------------------------
--문법순서
--select from where group by having order by
--실행순서 from where group by (그룹화)having(그룹의 조건)SELECT order by(정렬)

-- select from where groupby having orderby
-- 실행순서 from where groupby having select orderby

-- 관계설정 *******
CREATE TABLE ONE(
NO NUMBER,
NAME VARCHAR2(10));

CREATE TABLE TWO(
NUM NUMBER,
ADDR VARCHAR2(30)
);

SELECT * FROM ONE;
SELECT * FROM TWO;

INSERT INTO ONE VALUES(10, 'SEOUL1');
INSERT INTO ONE VALUES(20, 'SEOUL2');
INSERT INTO ONE VALUES(30, 'SEOUL3');
INSERT INTO ONE VALUES(40, 'SEOUL4');
INSERT INTO ONE VALUES(50, 'SEOUL5');-- PRIMARY KEY 로 잡혀져 있기 때문에 하나만 가능

INSERT INTO TWO VALUES(10, 'BUSAN1');
INSERT INTO TWO VALUES(20, 'BUSAN2');-- ONE 테이블에 20이 먼저 존재해야 추가 가능하다.
INSERT INTO TWO VALUES(30, 'BUSAN3');
INSERT INTO TWO VALUES(40, 'BUSAN4');
INSERT INTO TWO VALUES(50, 'BUSAN5');
INSERT INTO TWO VALUES(60, 'BUSAN6');-- ONE 테이블에 60이 없기에 안됨 FOREIGN KEY 제약조건 위배

-- 처음부터 제약조건을 추가하지 말기
-- ========↑ 관계 설정 전 테이블 1대 多 관계
DELETE FROM ONE;
DELETE FROM TWO;

-- 관계 설정
-- ONE 테이블의 프라이머리키를 NO칼럼의 PK_ONE_NO라는 제약조건을 추가
ALTER TABLE ONE ADD CONSTRAINT PK_ONE_NO PRIMARY KEY(NO);

--FOREIGN KEY : 외부테이블의 특정칼럼을 참조하는 외래키이다.
--참조할 칼럼은 무조건 primary key로 되어있어 된다.

-- NO 필드에 PK 적용
-- TWO 테이블의 외래키룰 NUM필드의 FK_TWO_NUM 이라는 이름으로 제약조건을 추가하는데 ONE테이블의 NO 필드를 참조하겠다.
ALTER TABLE TWO ADD CONSTRAINT FK_TWO_NUM FOREIGN KEY(NUM) REFERENCES ONE(NO);

-- 제약 조건 조회
select * from all_constraints where table_name='TWO';
select * from all_constraints where table_name='ONE';

-- 제약조건 삭제
ALTER TABLE TWO DROP CONSTRAINT FK_TWO_NUM;
ALTER TABLE ONE DROP CONSTRAINT PK_ONE_NO;

DELETE FROM TWO WHERE NUM=60;
-- 참조해주는 테이블 먼저 삭제 불가
DROP TABLE ONE; -- 참조된 테이블은 삭제할수없다. (자식이 있는 테이블)
DROP TABLE TWO;
-- ------제약 조건 미션
CREATE TABLE REGIONS3(
REGION_ID NUMBER,
REGION_NAME VARCHAR2(100));

CREATE TABLE COUNTRIES3(
COUNTRY_ID VARCHAR2(10),
COUNTRY_NAME VARCHAR2(100),
REGION_ID NUMBER
);

-- 제약조건 생성
ALTER TABLE REGIONS3 ADD CONSTRAINT PK_REGION_ID PRIMARY KEY(REGION_ID);
ALTER TABLE COUNTRIES3 ADD CONSTRAINT FK_COUNTRIES_REGION_ID FOREIGN KEY(REGION_ID) REFERENCES REGIONS3(REGION_ID);

INSERT INTO REGIONS3 VALUES(1, 'Europe');
INSERT INTO REGIONS3 VALUES(2, 'Americas');
INSERT INTO REGIONS3 VALUES(3, 'Asia');
INSERT INTO REGIONS3 VALUES(4, 'Middle East and Africa');

INSERT INTO COUNTRIES3 VALUES('AR', 'Argentina',2);
INSERT INTO COUNTRIES3 VALUES('AU', 'Australia',3);
INSERT INTO COUNTRIES3 VALUES('BE', 'Belgium',1);
INSERT INTO COUNTRIES3 VALUES('BR', 'Brazil',2);
INSERT INTO COUNTRIES3 VALUES('CA', 'Canada',2);

SELECT * FROM REGIONS3;
SELECT * FROM COUNTRIES3;

-- 제약 조건 조회
select * from all_constraints where table_name IN('REGIONS3','COUNTRIES3');



DROP TABLE EMP;
DROP TABLE DEPT;
purge RECYCLEBIN;
create table emp(
empno number(4),
ename varchar2(10),-- 사원이름
job varchar2(9),-- 직책
mgr number(4),-- 사수번호
hiredate date,-- 입사일
sal number(7,2),-- 소수점 두자리까지 나타내기 -- 급여
comm number(7,2),-- 커미션
deptno number(2)-- 부서번호
);
desc emp;
INSERT INTO EMP VALUES(7369,'SMITH','CLERK',7902,TO_DATE('17-12-1980','dd-mm-yyyy'),800,NULL,20);
INSERT INTO EMP VALUES (7499, 'ALLEN',  'SALESMAN',  7698,TO_DATE('20-02-1981', 'DD-MM-YYYY'), 1600,  300, 30);
INSERT INTO EMP VALUES(7521, 'WARD',   'SALESMAN',  7698,TO_DATE('22-02-1981', 'DD-MM-YYYY'), 1250,  500, 30);
INSERT INTO EMP VALUES(7566, 'JONES',  'MANAGER',   7839,TO_DATE('02-04-1981', 'DD-MM-YYYY'),  2975, NULL, 20);
INSERT INTO EMP VALUES(7654, 'MARTIN', 'SALESMAN',  7698,TO_DATE('28-09-1981', 'DD-MM-YYYY'), 1250, 1400, 30);
INSERT INTO EMP VALUES(7698, 'BLAKE',  'MANAGER',   7839,TO_DATE('01-05-1981', 'DD-MM-YYYY'),  2850, NULL, 30);
INSERT INTO EMP VALUES(7782, 'CLARK',  'MANAGER',   7839, TO_DATE('09-06-1981', 'DD-MM-YYYY'),  2450, NULL, 10);
INSERT INTO EMP VALUES(7788, 'SCOTT',  'ANALYST',   7566,TO_DATE('09-12-1982', 'DD-MM-YYYY'), 3000, NULL, 20);
INSERT INTO EMP VALUES(7839, 'KING',   'PRESIDENT', NULL, TO_DATE('17-11-1981', 'DD-MM-YYYY'), 5000, NULL, 10);
INSERT INTO EMP VALUES(7844, 'TURNER', 'SALESMAN',  7698, TO_DATE('08-09-1981', 'DD-MM-YYYY'),  1500, NULL, 30);
INSERT INTO EMP VALUES(7876, 'ADAMS',  'CLERK',     7788,TO_DATE('12-01-1983', 'DD-MM-YYYY'), 1100, NULL, 20);
INSERT INTO EMP VALUES(7900, 'JAMES',  'CLERK',     7698, TO_DATE('03-12-1981', 'DD-MM-YYYY'),   950, NULL, 30);
INSERT INTO EMP VALUES (7902, 'FORD',   'ANALYST',   7566, TO_DATE('03-12-1981', 'DD-MM-YYYY'),  3000, NULL, 20);
INSERT INTO EMP VALUES(7934, 'MILLER', 'CLERK',     7782, TO_DATE('23-01-1982', 'DD-MM-YYYY'), 1300, NULL, 10);

select * from emp;

-- 데이터 삭제
delete from emp;
-- 일부 삭제
delete from emp where empno=7499;

create table dept(
deptno number,
dname varchar2(14),
loc varchar2(13));
INSERT INTO dept VALUES(10,'ACCOUNTING','NEW YONK');
INSERT INTO dept VALUES(20,'RESEARCH','DALLAS');
INSERT INTO dept VALUES(30,'SALES','CHICAGO');
INSERT INTO dept VALUES(40,'OPERATIONS','BOSTON');
desc dept;


-- 관계 설정
-- dept 테이블의 deptno를 emp 테이블의 deptno 에 참조해주기
-- 제약조건 생성
ALTER TABLE dept ADD CONSTRAINT PK_DEPT_DEPTNO PRIMARY KEY(DEPTNO);
ALTER TABLE EMP ADD CONSTRAINT FK_EMP_DEPTNO FOREIGN KEY(DEPTNO) REFERENCES DEPT(DEPTNO);

select * from all_constraints where table_name IN('DEPT','EMP');

COMMIT; 

-- ----------------------------------------------------------
-- JOIN**********테이블 간의 결합
-- ----------------------------------------------------------
CREATE TABLE TBL1(
ID NUMBER,
NAME VARCHAR2(10)
);
CREATE TABLE TBL2(
ID NUMBER,
CAR VARCHAR2(10)
);
INSERT INTO TBL1 VALUES (1, 'AAA');
INSERT INTO TBL1 VALUES (2, 'BBB');
INSERT INTO TBL1 VALUES (3, 'CCC');
INSERT INTO TBL1 VALUES (4, 'DDD');
INSERT INTO TBL1 VALUES (5, 'EEE');


INSERT INTO TBL2 VALUES (2, 'AVANTE');
INSERT INTO TBL2 VALUES (3, 'SONATA');
INSERT INTO TBL2 VALUES (2, 'MINI');
INSERT INTO TBL2 VALUES (6, 'PONY'); -- TBL1에 없기 떄문에 안나옴

-- JOIN 의 두가지 형태
-- ANSI JOIN : 국제표준형태의 조인 
-- INNER JOIN
-- 중복되지 않은 칼럼명이라면 별칭을 빼도 된다.
SELECT A.ID, A.NAME, B.CAR
FROM TBL1 A
INNER JOIN TBL2 B
ON A.ID=B.ID;

-- ORACLE JOIN : 오라클에서 만들어둔 조인
SELECT A.ID, A.NAME, B.CAR
FROM TBL1 A, TBL2 B
WHERE A.ID=B.ID;

-- LEFT OUTER JOIN 왼쪽 테이블 전체와 오른쪽 테이블의 교집합
-- ANSI JOIN
SELECT T1.ID, T1.NAME, T2.CAR
FROM TBL1 T1
LEFT OUTER JOIN TBL2 T2
ON T1.ID = T2.ID;

-- ORACLE JOIN
SELECT T1.ID, T1.NAME, T2.CAR
FROM TBL1 T1,TBL2 T2
WHERE T1.ID = T2.ID(+);

-- RIGHT OUTER JOIN 오른쪽 테이블 전체와 왼쪽 테이블의 교집합
-- ANSI JOIN
SELECT T1.ID, T1.NAME, T2.CAR
FROM TBL1 T1
RIGHT OUTER JOIN TBL2 T2
ON T1.ID = T2.ID;

-- ORACLE JOIN
SELECT T1.ID, T1.NAME, T2.CAR
FROM TBL1 T1,TBL2 T2
WHERE T1.ID (+)= T2.ID;


-- 공통부분 제외
SELECT T1.ID, T1.NAME, T2.CAR
FROM TBL1 T1
RIGHT OUTER JOIN TBL2 T2
ON T1.ID = T2.ID
WHERE T1.ID IS NULL;

-- 공통부분만 조회
SELECT T1.ID, T1.NAME, T2.CAR
FROM TBL1 T1
RIGHT OUTER JOIN TBL2 T2
ON T1.ID = T2.ID
WHERE T1.ID IS NOT NULL;

-- FULL OUTER JOIN
-- ANSI JOIN
SELECT T1.ID, T1.NAME, T2.CAR
FROM TBL1 T1
FULL OUTER JOIN TBL2 T2
ON T1.ID=T2.ID;

-- ORACLE JOIN
SELECT T1.ID, T1.NAME, T2.CAR
FROM TBL1 T1,TBL2 T2
WHERE T1.ID=T2.ID(+)
UNION
SELECT T1.ID, T1.NAME, T2.CAR
FROM TBL1 T1,TBL2 T2
WHERE T1.ID(+)=T2.ID;

--공통부분 제거
SELECT T1.ID, T1.NAME, T2.CAR
FROM TBL1 T1
FULL OUTER JOIN TBL2 T2
ON T1.ID=T2.ID
WHERE T2.CAR IS NULL OR T1.ID IS NULL;

-- JOIN 활용
-- EMP DEPT 테이블 활용
-- 사원 테이블에서 부서코드에 매칭되는 부서의 이름을 출력
-- EMPNO, ENAME, DEPTNO, DNAME
SELECT E.EMPNO, E.ENAME, D.DEPTNO, D.DNAME
FROM EMP E
INNER JOIN DEPT D
ON E.DEPTNO=D.DEPTNO;

-- 학생과 교수테이블을 JOIN 하여 학생이름, 지도교수 번호, 지도교수 이름 출력
SELECT * FROM STUDENT;
SELECT * FROM PROFESSOR;

SELECT S.NAME, P.PROFNO, P.NAME
FROM STUDENT S
INNER JOIN PROFESSOR P
ON S.PROFNO=P.PROFNO
ORDER BY S.NAME;

-- 위 내용을 오라클 조인 처리
SELECT S.NAME, P.PROFNO, P.NAME
FROM STUDENT S, PROFESSOR P
WHERE S.PROFNO=P.PROFNO
ORDER BY S.NAME;

-- UPDATE 내용 수정
-- UPDATE 테이블 SET 칼럼1='벨류1', 칼럼2='벨류2' WHERE 조건;

-- 테이블 복사
CREATE TABLE EMP2
AS
SELECT * FROM EMP;

SELECT * FROM EMP2;

-- allen 의 급여를 500 인상
update emp2 set sal=sal+500 WHERE ENAME='ALLEN';

-- JAMES 급여 천달러 인상
UPDATE EMP2 SET SAL = SAL+1000 WHERE ENAME='JAMES';

-- MARTHIN, BLAKE 500 인상 
UPDATE EMP2 SET SAL = SAL+500 WHERE ENAME IN('MARTHIN','BLAKE');

DROP TABLE EMP2 PURGE;

CREATE TABLE EMP2 AS SELECT * FROM EMP;

-- SAL가 2000이하인 사람의 급여 1000 인상
UPDATE EMP2 SET SAL = SAL+1000 WHERE SAL<=2000;

-- 복수 칼럼 적용
-- SAL 3000이상인 사람의 SAL 100인상, COMM을 1000으로 수정
UPDATE EMP2 SET SAL = SAL+1000, COMM=1000 WHERE SAL>=3000;

-- SAL 2000이상이고 DEPTNO 20인 사람의 SAL 1000인상, COMM 2000 수정
UPDATE EMP2 SET SAL=SAL+1000, COMM=2000 WHERE SAL>=2000 AND DEPTNO=20;

-- 직급이 조교수 assistant professor 보너스를 200만원인상
select * from professor where position='assistant professor';

UPDATE PROFESSOR SET BONUS=nvl(BONUS,0)+200 WHERE POSITION='assistant professor';
UPDATE PROFESSOR SET BONUS=nvl2(BONUS,BONUS+200,0+200) WHERE POSITION='assistant professor';


-- 미션
CREATE TABLE STADIUM(
STADIUM_ID VARCHAR2(10),
STADIUM_NAME VARCHAR2(100),
SEAT_COUNT NUMBER
);

CREATE TABLE PLAYER(
PLAYER_ID NUMBER,
PLAYER_NAME VARCHAR2(100),
TEAM_ID VARCHAR2(10)
);

CREATE TABLE TEAM(
TEAM_ID VARCHAR2(10),
TEAM_NAME VARCHAR2(100),
REGION_NAME VARCHAR2(50),
STADIUM_ID VARCHAR2(10)
);


DROP TABLE STADIUM;
DROP TABLE PLAYER;
DROP TABLE TEAM;


ALTER TABLE STADIUM ADD CONSTRAINT PK_STADIUM_ID PRIMARY KEY(STADIUM_ID);

ALTER TABLE TEAM ADD CONSTRAINT PK_TEAM_ID PRIMARY KEY(TEAM_ID);

ALTER TABLE TEAM ADD CONSTRAINT FK_TEAM_STADIUM_ID FOREIGN KEY(STADIUM_ID) REFERENCES STADIUM(STADIUM_ID);
ALTER TABLE PLAYER ADD CONSTRAINT FK_PLAYER_TEAM_ID FOREIGN KEY(TEAM_ID) REFERENCES TEAM(TEAM_ID);

SELECT * FROM all_constraints WHERE table_name IN('STADIUM','PLAYER','TEAM');
SELECT * FROM PLAYER;
SELECT * FROM STADIUM;
SELECT * FROM TEAM;

INSERT INTO PLAYER VALUES(2012137,'이고르','K06');
INSERT INTO PLAYER VALUES(2012136,'이보으','K06');
INSERT INTO PLAYER VALUES(2012135,'이두오','K01');
INSERT INTO PLAYER VALUES(2012134,'이시어','K02');

INSERT INTO STADIUM VALUES('A01','전주월드컵경기장',28000);
INSERT INTO STADIUM VALUES('B01','전주월드컵경기장2',29000);
INSERT INTO STADIUM VALUES('C01','전주월드컵경기장3',29500);

INSERT INTO TEAM VALUES('K01','현대모터스','전북','A01');
INSERT INTO TEAM VALUES('K02','현대모터스2','전북2','B01');
INSERT INTO TEAM VALUES('K06','현대모터스3','전북3','C01');


COMMIT;
rollback;